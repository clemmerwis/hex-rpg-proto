<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hex RPG Prototype</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #1a1a1a;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            height: 100vh;
            font-family: Arial, sans-serif;
            overflow: hidden;
            /* Prevent any scrolling */
        }

        #gameCanvas {
            margin-top: 20px;
            border: 2px solid #333;
            cursor: pointer;
            display: block;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
        }

        #debugInfo {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: #ffffff;
            background-color: rgba(0, 0, 0, 0.8);
            padding: 15px 25px;
            border-radius: 5px;
            font-size: 14px;
            font-family: monospace;
            border: 1px solid rgba(255, 255, 255, 0.3);
            z-index: 1000;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.9);
            text-align: center;
        }

        #debugInfo label {
            color: #ffffff;
            cursor: pointer;
        }

        #debugInfo input[type="checkbox"] {
            margin-right: 5px;
            cursor: pointer;
        }
    </style>
</head>

<body>
    <canvas id="gameCanvas"></canvas>

    <div id="debugInfo">
        <div>Mouse: <span id="mousePos">0, 0</span></div>
        <div>Hex: <span id="hexPos">-, -</span></div>
        <div>Assets: <span id="loadStatus">Loading...</span></div>
        <div><label><input type="checkbox" id="showGrid" checked> Show Grid</label></div>
        <div style="margin-top: 10px; font-size: 12px;">
            <strong>Edge Scroll:</strong> Move mouse to edges<br>
            <strong>Camera:</strong> <span id="cameraPos">0, 0</span><br>
            <strong>PC Direction:</strong> <span id="directionInfo">dir8</span><br>
            <strong>Animation:</strong> <span id="animationInfo">idle</span><br>
            <strong>Keys:</strong> 1-6 for animations, Click to face direction
        </div>
    </div>

    <script>
        // World size (full gameboard)
        const WORLD_WIDTH = 3220;
        const WORLD_HEIGHT = 2240;

        // Viewport size (what we see on screen)
        const VIEWPORT_WIDTH = Math.min(window.innerWidth * 0.9, 1600);
        const VIEWPORT_HEIGHT = Math.min(window.innerHeight * 0.85, 900);

        // Camera position (top-left corner of viewport in world coordinates)
        let cameraX = 0;
        let cameraY = 0;

        // Zoom level (fixed, far out view)
        const zoomLevel = 0.5; // Smaller value = farther out

        // Canvas setup
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Set canvas to viewport size
        canvas.width = VIEWPORT_WIDTH;
        canvas.height = VIEWPORT_HEIGHT;

        // Debug elements
        const mousePosEl = document.getElementById('mousePos');
        const hexPosEl = document.getElementById('hexPos');
        const loadStatusEl = document.getElementById('loadStatus');
        const showGridCheckbox = document.getElementById('showGrid');
        const cameraPosEl = document.getElementById('cameraPos');
        const directionEl = document.getElementById('directionInfo');
        const animationEl = document.getElementById('animationInfo');

        // Key state tracking for diagonal movement
        const keys = {};

        // Animation configuration
        const animationConfig = {
            'idle': { cols: 5, rows: 4, frameCount: 17 },   // 5×4 grid, 17 frames used
            'walk': { cols: 4, rows: 3, frameCount: 11 },   // 4×3 grid, 11 frames used
            'run': { cols: 3, rows: 3, frameCount: 8 },     // 3×3 grid, 8 frames used
            'jump': { cols: 4, rows: 3, frameCount: 11 },   // 4×3 grid, 11 frames used
            'attack': { cols: 4, rows: 4, frameCount: 15 }, // 4×4 grid, 15 frames used
            'die': { cols: 6, rows: 5, frameCount: 27 }     // 6×5 grid, 27 frames used
        };

        // Game state
        const game = {
            assets: {
                background: null,
                knightSprites: {} // Store all directional sprites
            },
            pc: {
                hexQ: 5,         // Moved left from 10 to 5
                hexR: -5,        // Moved up from 0 to -5
                pixelX: 0,
                pixelY: 0,
                facing: 'dir8', // Default facing down
                animationFrame: 0,
                animationTimer: 0,
                currentAnimation: 'idle',
                name: 'Hero',
                health: 85,
                maxHealth: 100
            },
            npcs: [
                {
                    hexQ: 7,         // Near PC, slightly to the right
                    hexR: -3,        // Near PC, slightly down
                    pixelX: 0,
                    pixelY: 0,
                    facing: 'dir4',  // Facing up
                    animationFrame: 3, // Start at different frame
                    animationTimer: 75, // Offset timing
                    currentAnimation: 'idle',
                    name: 'Guard',
                    health: 60,
                    maxHealth: 80
                }
            ]
        };

        // Hex grid configuration
        const HEX_SIZE = 70;
        const HEX_WIDTH = Math.sqrt(3) * HEX_SIZE;
        const HEX_HEIGHT = 2 * HEX_SIZE;

        // Hex grid utilities
        const HexGrid = {
            hexToPixel: function (q, r) {
                const x = HEX_SIZE * (Math.sqrt(3) * q + Math.sqrt(3) / 2 * r) + WORLD_WIDTH / 2;
                const y = HEX_SIZE * (3 / 2 * r) + WORLD_HEIGHT / 2;
                return { x, y };
            },

            pixelToHex: function (x, y) {
                x -= WORLD_WIDTH / 2;
                y -= WORLD_HEIGHT / 2;

                const q = (Math.sqrt(3) / 3 * x - 1 / 3 * y) / HEX_SIZE;
                const r = (2 / 3 * y) / HEX_SIZE;

                return this.roundHex(q, r);
            },

            roundHex: function (q, r) {
                const s = -q - r;
                let rq = Math.round(q);
                let rr = Math.round(r);
                let rs = Math.round(s);

                const q_diff = Math.abs(rq - q);
                const r_diff = Math.abs(rr - r);
                const s_diff = Math.abs(rs - s);

                if (q_diff > r_diff && q_diff > s_diff) {
                    rq = -rr - rs;
                } else if (r_diff > s_diff) {
                    rr = -rq - rs;
                }

                return { q: rq, r: rr };
            }
        };

        // Asset loading
        function loadAssets() {
            let assetsLoaded = 0;
            let totalAssets = 1; // Start with background

            // Count total assets (8 directions × number of animations)
            const directions = ['dir1', 'dir2', 'dir3', 'dir4', 'dir5', 'dir6', 'dir7', 'dir8'];
            const animations = ['Idle', 'Walk', 'Run', 'Attack', 'Jump', 'Die']; // Available animations
            totalAssets += directions.length * animations.length;

            // Load background
            game.assets.background = new Image();
            game.assets.background.onload = () => {
                assetsLoaded++;
                checkAssetsLoaded();
            };
            game.assets.background.onerror = () => {
                console.log("Background failed to load, using placeholder");
                assetsLoaded++;
                game.assets.background = null;
                checkAssetsLoaded();
            };
            game.assets.background.src = 'IsometricBridge.jpg';

            // Load knight sprites for each direction
            directions.forEach(dir => {
                game.assets.knightSprites[dir] = {};

                animations.forEach(anim => {
                    const sprite = new Image();
                    sprite.onload = () => {
                        assetsLoaded++;
                        checkAssetsLoaded();
                    };
                    sprite.onerror = () => {
                        console.log(`Failed to load Knight_${anim}_${dir}.png`);
                        assetsLoaded++;
                        checkAssetsLoaded();
                    };
                    // Path based on your file structure
                    sprite.src = `sprites/KnightBasic/${anim}/Knight_${anim}_${dir}.png`;
                    game.assets.knightSprites[dir][anim.toLowerCase()] = sprite;
                });
            });

            function checkAssetsLoaded() {
                const loadPercent = Math.round((assetsLoaded / totalAssets) * 100);
                loadStatusEl.textContent = `Loading: ${loadPercent}%`;

                if (assetsLoaded === totalAssets) {
                    loadStatusEl.textContent = 'Ready';
                    loadStatusEl.style.color = '#0f0';

                    // Set PC starting position
                    const startPos = HexGrid.hexToPixel(game.pc.hexQ, game.pc.hexR);
                    game.pc.pixelX = startPos.x;
                    game.pc.pixelY = startPos.y;

                    // Set NPC starting positions
                    game.npcs.forEach(npc => {
                        const npcStartPos = HexGrid.hexToPixel(npc.hexQ, npc.hexR);
                        npc.pixelX = npcStartPos.x;
                        npc.pixelY = npcStartPos.y;
                    });

                    // Center camera on PC (original behavior)
                    centerCameraOn(game.pc.pixelX, game.pc.pixelY);

                    // Start render loop
                    gameLoop();
                }
            }
        }

        // Center camera on a world position
        function centerCameraOn(worldX, worldY) {
            cameraX = (worldX * zoomLevel) - VIEWPORT_WIDTH / 2;
            cameraY = (worldY * zoomLevel) - VIEWPORT_HEIGHT / 2;
            clampCamera();
        }

        // Keep camera within world bounds
        function clampCamera() {
            const maxCameraX = WORLD_WIDTH * zoomLevel - VIEWPORT_WIDTH;
            const maxCameraY = WORLD_HEIGHT * zoomLevel - VIEWPORT_HEIGHT;

            cameraX = Math.max(0, Math.min(cameraX, maxCameraX));
            cameraY = Math.max(0, Math.min(cameraY, maxCameraY));

            // Update debug display
            cameraPosEl.textContent = `${Math.round(cameraX)}, ${Math.round(cameraY)}`;
        }

        // Game loop
        function gameLoop() {
            updateAnimations();
            updateKeyboardScrolling();
            render();
            requestAnimationFrame(gameLoop);
        }

        // Update animations
        function updateAnimations() {
            // Animation speed (lower = faster)
            const ANIMATION_SPEED = 150; // milliseconds per frame

            // Update PC animation
            game.pc.animationTimer += 16; // Approximately 60fps
            if (game.pc.animationTimer >= ANIMATION_SPEED) {
                game.pc.animationTimer = 0;
                const animConfig = animationConfig[game.pc.currentAnimation];
                let frameCount = animConfig ? animConfig.frameCount : 6;
                game.pc.animationFrame = (game.pc.animationFrame + 1) % frameCount;
            }

            // Update NPC animations
            game.npcs.forEach(npc => {
                npc.animationTimer += 16;
                if (npc.animationTimer >= ANIMATION_SPEED) {
                    npc.animationTimer = 0;
                    const animConfig = animationConfig[npc.currentAnimation];
                    let frameCount = animConfig ? animConfig.frameCount : 6;
                    npc.animationFrame = (npc.animationFrame + 1) % frameCount;
                }
            });
        }

        // Update keyboard scrolling (called in game loop)
        function updateKeyboardScrolling() {
            const KEYBOARD_SCROLL_SPEED = 15;

            let scrollX = 0;
            let scrollY = 0;

            // Check all movement keys
            if (keys['ArrowUp'] || keys['w'] || keys['W']) scrollY -= KEYBOARD_SCROLL_SPEED;
            if (keys['ArrowDown'] || keys['s'] || keys['S']) scrollY += KEYBOARD_SCROLL_SPEED;
            if (keys['ArrowLeft'] || keys['a'] || keys['A']) scrollX -= KEYBOARD_SCROLL_SPEED;
            if (keys['ArrowRight'] || keys['d'] || keys['D']) scrollX += KEYBOARD_SCROLL_SPEED;

            // Apply movement
            if (scrollX !== 0 || scrollY !== 0) {
                cameraX += scrollX;
                cameraY += scrollY;
                clampCamera();
            }
        }

        // Draw nameplate (name and health bar) above character
        function drawNameplate(character, isPC = false) {
            // Account for actual rendered sprite size with zoom level
            const actualSpriteSize = 256 * zoomLevel; // Sprite size after zoom scaling
            const nameplateY = character.pixelY - actualSpriteSize / 2 - 45; // ADJUST THIS NUMBER to raise/lower nameplate

            // Calculate nameplate background dimensions
            const barWidth = 140;
            const barHeight = 20;
            const nameplatePadding = 8;
            const nameplateWidth = Math.max(barWidth, 120) + (nameplatePadding * 2); // Ensure it covers name and health bar
            const nameplateHeight = 70; // Height to cover name + health bar + spacing
            const nameplateX = character.pixelX - nameplateWidth / 2;
            const nameplateBackgroundY = nameplateY - 45; // Position to cover name text

            ctx.save();

            // Draw semi-transparent black background
            ctx.fillStyle = 'rgba(0, 0, 0, 0.6)'; // Black with 60% opacity
            ctx.fillRect(nameplateX, nameplateBackgroundY, nameplateWidth, nameplateHeight);

            // Optional: Add a subtle border to the background
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 1;
            ctx.strokeRect(nameplateX, nameplateBackgroundY, nameplateWidth, nameplateHeight);

            // Name text
            ctx.font = 'bold 36px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'bottom';

            // Text shadow for better readability
            ctx.fillStyle = 'rgba(0, 0, 0, 0.9)';
            ctx.fillText(character.name, character.pixelX + 3, nameplateY + 3);

            // Main text color (different for PC vs NPC)
            ctx.fillStyle = isPC ? '#00ff00' : '#ffffff';
            ctx.fillText(character.name, character.pixelX, nameplateY);

            // Health bar background
            const barX = character.pixelX - barWidth / 2;
            const barY = nameplateY + 10; // ADJUST THIS NUMBER to change spacing between name and health bar

            // Background (red)
            ctx.fillStyle = 'rgba(150, 0, 0, 0.9)';
            ctx.fillRect(barX, barY, barWidth, barHeight);

            // Health fill (green)
            const healthPercent = character.health / character.maxHealth;
            const healthWidth = barWidth * healthPercent;
            ctx.fillStyle = 'rgba(0, 200, 0, 0.9)';
            ctx.fillRect(barX, barY, healthWidth, barHeight);

            // Health bar border
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.9)';
            ctx.lineWidth = 3;
            ctx.strokeRect(barX, barY, barWidth, barHeight);

            // Health text
            ctx.font = 'bold 20px Arial';
            ctx.fillStyle = 'white';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(`${character.health}/${character.maxHealth}`, character.pixelX, barY + barHeight / 2);

            ctx.restore();
        }

        // Draw character sprite
        function drawCharacter(character) {
            if (game.assets.knightSprites[character.facing] &&
                game.assets.knightSprites[character.facing][character.currentAnimation]) {

                const sprite = game.assets.knightSprites[character.facing][character.currentAnimation];
                const frameSize = 256; // Each frame is 256x256

                // Get animation configuration
                const animConfig = animationConfig[character.currentAnimation];
                const framesPerRow = animConfig ? animConfig.cols : Math.floor(sprite.width / frameSize);

                // Calculate grid position
                const col = character.animationFrame % framesPerRow;
                const row = Math.floor(character.animationFrame / framesPerRow);

                // Calculate pixel position in sprite sheet
                const frameX = col * frameSize;
                const frameY = row * frameSize;

                // Draw sprite
                if (frameX + frameSize <= sprite.width && frameY + frameSize <= sprite.height) {
                    ctx.drawImage(
                        sprite,
                        frameX, frameY, frameSize, frameSize,
                        character.pixelX - frameSize / 2, character.pixelY - frameSize / 2, frameSize, frameSize
                    );
                } else {
                    ctx.drawImage(
                        sprite,
                        0, 0, frameSize, frameSize,
                        character.pixelX - frameSize / 2, character.pixelY - frameSize / 2, frameSize, frameSize
                    );
                }
            } else {
                // Placeholder character (circle)
                ctx.fillStyle = '#ff0000';
                ctx.beginPath();
                ctx.arc(character.pixelX, character.pixelY, 30, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 3;
                ctx.stroke();
            }
        }

        // Rendering
        function render() {
            // Clear canvas
            ctx.fillStyle = '#2a2a2a';
            ctx.fillRect(0, 0, VIEWPORT_WIDTH, VIEWPORT_HEIGHT);

            // Save context state
            ctx.save();

            // Apply camera transform
            ctx.scale(zoomLevel, zoomLevel);
            ctx.translate(-cameraX / zoomLevel, -cameraY / zoomLevel);

            // Draw background
            if (game.assets.background) {
                ctx.drawImage(game.assets.background, 0, 0, WORLD_WIDTH, WORLD_HEIGHT);
            } else {
                // Placeholder background
                ctx.fillStyle = '#1a3a1a';
                ctx.fillRect(0, 0, WORLD_WIDTH, WORLD_HEIGHT);

                ctx.strokeStyle = '#0a2a0a';
                ctx.lineWidth = 1;
                for (let x = 0; x < WORLD_WIDTH; x += 100) {
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, WORLD_HEIGHT);
                    ctx.stroke();
                }
                for (let y = 0; y < WORLD_HEIGHT; y += 100) {
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(WORLD_WIDTH, y);
                    ctx.stroke();
                }
            }

            // Draw hex grid
            if (showGridCheckbox.checked) {
                drawHexGrid();
            }

            // Draw PC
            drawCharacter(game.pc);
            drawNameplate(game.pc, true); // true indicates this is the PC

            // Draw NPCs
            game.npcs.forEach(npc => {
                drawCharacter(npc);
                drawNameplate(npc, false); // false indicates this is an NPC
            });

            // Restore context state
            ctx.restore();
        }

        // Draw hex grid (only visible hexes)
        function drawHexGrid() {
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
            ctx.lineWidth = 2;

            // Calculate visible hex bounds with extra margin
            const margin = HEX_SIZE * 2;
            const startX = (cameraX / zoomLevel) - margin;
            const startY = (cameraY / zoomLevel) - margin;
            const endX = ((cameraX + VIEWPORT_WIDTH) / zoomLevel) + margin;
            const endY = ((cameraY + VIEWPORT_HEIGHT) / zoomLevel) + margin;

            // Convert to hex coordinates
            const startHex = HexGrid.pixelToHex(startX, startY);
            const endHex = HexGrid.pixelToHex(endX, endY);

            // Draw only visible hexes with extra buffer
            for (let q = startHex.q - 5; q <= endHex.q + 5; q++) {
                for (let r = startHex.r - 5; r <= endHex.r + 5; r++) {
                    const pos = HexGrid.hexToPixel(q, r);
                    // Only draw if hex center is within world bounds
                    if (pos.x >= -HEX_SIZE && pos.x <= WORLD_WIDTH + HEX_SIZE &&
                        pos.y >= -HEX_SIZE && pos.y <= WORLD_HEIGHT + HEX_SIZE) {
                        drawHex(q, r);
                    }
                }
            }
        }

        // Draw a single hex
        function drawHex(q, r) {
            const center = HexGrid.hexToPixel(q, r);

            ctx.beginPath();
            for (let i = 0; i < 6; i++) {
                const angle = 2 * Math.PI / 6 * i - Math.PI / 6;
                const x = center.x + HEX_SIZE * Math.cos(angle);
                const y = center.y + HEX_SIZE * Math.sin(angle);

                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.closePath();
            ctx.stroke();
        }

        // Mouse edge scrolling with variable speed
        let mouseX = 0;
        let mouseY = 0;
        let isMouseOverCanvas = false;

        canvas.addEventListener('mouseenter', () => isMouseOverCanvas = true);
        canvas.addEventListener('mouseleave', () => isMouseOverCanvas = false);

        function updateEdgeScrolling() {
            if (!isMouseOverCanvas) {
                requestAnimationFrame(updateEdgeScrolling);
                return;
            }

            const EDGE_THRESHOLD = 150;
            const MAX_SCROLL_SPEED = 12; // Reduced from 25

            const rect = canvas.getBoundingClientRect();
            const relativeX = mouseX - rect.left;
            const relativeY = mouseY - rect.top;

            let scrollX = 0;
            let scrollY = 0;

            // Calculate distance from edges
            const leftDistance = relativeX;
            const rightDistance = rect.width - relativeX;
            const topDistance = relativeY;
            const bottomDistance = rect.height - relativeY;

            // Variable speed based on distance from edge
            if (leftDistance < EDGE_THRESHOLD && leftDistance >= 0) {
                const speedMultiplier = 1 - (leftDistance / EDGE_THRESHOLD);
                scrollX = -MAX_SCROLL_SPEED * speedMultiplier;
            } else if (rightDistance < EDGE_THRESHOLD && rightDistance >= 0) {
                const speedMultiplier = 1 - (rightDistance / EDGE_THRESHOLD);
                scrollX = MAX_SCROLL_SPEED * speedMultiplier;
            }

            if (topDistance < EDGE_THRESHOLD && topDistance >= 0) {
                const speedMultiplier = 1 - (topDistance / EDGE_THRESHOLD);
                scrollY = -MAX_SCROLL_SPEED * speedMultiplier;
            } else if (bottomDistance < EDGE_THRESHOLD && bottomDistance >= 0) {
                const speedMultiplier = 1 - (bottomDistance / EDGE_THRESHOLD);
                scrollY = MAX_SCROLL_SPEED * speedMultiplier;
            }

            // Apply scrolling
            if (scrollX !== 0 || scrollY !== 0) {
                cameraX += scrollX;
                cameraY += scrollY;
                clampCamera();
            }

            requestAnimationFrame(updateEdgeScrolling);
        }
        updateEdgeScrolling();

        // Mouse handling
        canvas.addEventListener('mousemove', (e) => {
            mouseX = e.clientX;
            mouseY = e.clientY;

            const rect = canvas.getBoundingClientRect();
            const canvasX = e.clientX - rect.left;
            const canvasY = e.clientY - rect.top;

            // Convert to world coordinates
            const worldX = (canvasX + cameraX) / zoomLevel;
            const worldY = (canvasY + cameraY) / zoomLevel;

            mousePosEl.textContent = `${Math.round(worldX)}, ${Math.round(worldY)}`;

            const hex = HexGrid.pixelToHex(worldX, worldY);
            hexPosEl.textContent = `${hex.q}, ${hex.r}`;
        });

        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const canvasX = e.clientX - rect.left;
            const canvasY = e.clientY - rect.top;

            // Convert to world coordinates
            const worldX = (canvasX + cameraX) / zoomLevel;
            const worldY = (canvasY + cameraY) / zoomLevel;

            const hex = HexGrid.pixelToHex(worldX, worldY);
            console.log(`Clicked hex: q=${hex.q}, r=${hex.r}`);

            // Calculate direction to face
            const targetPos = HexGrid.hexToPixel(hex.q, hex.r);
            const dx = targetPos.x - game.pc.pixelX;
            const dy = targetPos.y - game.pc.pixelY;

            // Calculate angle and convert to 8-direction
            let angle = Math.atan2(dy, dx) * 180 / Math.PI;
            angle = (angle + 360) % 360; // Normalize to 0-360

            // Map angle to direction
            if (angle >= 337.5 || angle < 22.5) game.pc.facing = 'dir6';      // Right
            else if (angle >= 22.5 && angle < 67.5) game.pc.facing = 'dir7';  // Down-Right
            else if (angle >= 67.5 && angle < 112.5) game.pc.facing = 'dir8'; // Down
            else if (angle >= 112.5 && angle < 157.5) game.pc.facing = 'dir1'; // Down-Left
            else if (angle >= 157.5 && angle < 202.5) game.pc.facing = 'dir2'; // Left
            else if (angle >= 202.5 && angle < 247.5) game.pc.facing = 'dir3'; // Up-Left
            else if (angle >= 247.5 && angle < 292.5) game.pc.facing = 'dir4'; // Up
            else if (angle >= 292.5 && angle < 337.5) game.pc.facing = 'dir5'; // Up-Right

            // Update debug display
            directionEl.textContent = game.pc.facing;
        });

        // Keyboard state tracking
        document.addEventListener('keydown', (e) => {
            keys[e.key] = true;

            // Handle animation changes immediately on keydown
            switch (e.key) {
                case '1':
                    game.pc.currentAnimation = 'idle';
                    console.log('Animation: Idle');
                    animationEl.textContent = game.pc.currentAnimation;
                    break;
                case '2':
                    game.pc.currentAnimation = 'walk';
                    console.log('Animation: Walk');
                    animationEl.textContent = game.pc.currentAnimation;
                    break;
                case '3':
                    game.pc.currentAnimation = 'run';
                    console.log('Animation: Run');
                    animationEl.textContent = game.pc.currentAnimation;
                    break;
                case '4':
                    game.pc.currentAnimation = 'attack';
                    console.log('Animation: Attack');
                    animationEl.textContent = game.pc.currentAnimation;
                    break;
                case '5':
                    game.pc.currentAnimation = 'jump';
                    console.log('Animation: Jump');
                    animationEl.textContent = game.pc.currentAnimation;
                    break;
                case '6':
                    game.pc.currentAnimation = 'die';
                    console.log('Animation: Die');
                    animationEl.textContent = game.pc.currentAnimation;
                    break;
            }
        });

        document.addEventListener('keyup', (e) => {
            keys[e.key] = false;
        });

        // Grid toggle listener
        showGridCheckbox.addEventListener('change', () => {
            requestAnimationFrame(render);
        });

        // Initialize
        loadAssets();
    </script>
</body>

</html>