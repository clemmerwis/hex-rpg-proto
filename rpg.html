<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hex RPG Prototype</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #1a1a1a;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            height: 100vh;
            font-family: Arial, sans-serif;
            overflow: hidden;
            /* Prevent any scrolling */
        }

        #gameCanvas {
            margin-top: 20px;
            border: 2px solid #333;
            cursor: pointer;
            display: block;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
        }

        #debugInfo {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: #ffffff;
            background-color: rgba(0, 0, 0, 0.8);
            padding: 15px 25px;
            border-radius: 5px;
            font-size: 14px;
            font-family: monospace;
            border: 1px solid rgba(255, 255, 255, 0.3);
            z-index: 1000;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.9);
            text-align: center;
        }

        #debugInfo label {
            color: #ffffff;
            cursor: pointer;
        }

        #debugInfo input[type="checkbox"] {
            margin-right: 5px;
            cursor: pointer;
        }
    </style>
</head>

<body>
    <canvas id="gameCanvas"></canvas>

    <div id="debugInfo">
        <div>Mouse: <span id="mousePos">0, 0</span></div>
        <div>Hex: <span id="hexPos">-, -</span></div>
        <div>Assets: <span id="loadStatus">Loading...</span></div>
        <div><label><input type="checkbox" id="showGrid" checked> Show Grid</label></div>
        <div style="margin-top: 10px; font-size: 12px;">
            <strong>Edge Scroll:</strong> Move mouse to edges<br>
            <strong>Camera:</strong> <span id="cameraPos">0, 0</span><br>
            <strong>Direction:</strong> <span id="directionInfo">dir8</span><br>
            <strong>Animation:</strong> <span id="animationInfo">idle</span><br>
            <strong>Keys:</strong> 1-6 for animations, Click to face direction
        </div>
    </div>

    <script>
        // World size (full gameboard)
        const WORLD_WIDTH = 3220;
        const WORLD_HEIGHT = 2240;

        // Viewport size (what we see on screen)
        const VIEWPORT_WIDTH = Math.min(window.innerWidth * 0.9, 1600);
        const VIEWPORT_HEIGHT = Math.min(window.innerHeight * 0.85, 900);

        // Camera position (top-left corner of viewport in world coordinates)
        let cameraX = 0;
        let cameraY = 0;

        // Zoom level (fixed, far out view)
        const zoomLevel = 0.5; // Smaller value = farther out

        // Canvas setup
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Set canvas to viewport size
        canvas.width = VIEWPORT_WIDTH;
        canvas.height = VIEWPORT_HEIGHT;

        // Debug elements
        const mousePosEl = document.getElementById('mousePos');
        const hexPosEl = document.getElementById('hexPos');
        const loadStatusEl = document.getElementById('loadStatus');
        const showGridCheckbox = document.getElementById('showGrid');
        const cameraPosEl = document.getElementById('cameraPos');
        const directionEl = document.getElementById('directionInfo');
        const animationEl = document.getElementById('animationInfo');

        // Game state
        const game = {
            assets: {
                background: null,
                knightSprites: {} // Store all directional sprites
            },
            pc: {
                hexQ: 10,
                hexR: 5,
                pixelX: 0,
                pixelY: 0,
                facing: 'dir8', // Default facing down
                animationFrame: 0,
                animationTimer: 0,
                currentAnimation: 'idle' // idle, walk, run, attack
            }
        };

        // Hex grid configuration
        const HEX_SIZE = 70;
        const HEX_WIDTH = Math.sqrt(3) * HEX_SIZE;
        const HEX_HEIGHT = 2 * HEX_SIZE;

        // Hex grid utilities
        const HexGrid = {
            hexToPixel: function (q, r) {
                const x = HEX_SIZE * (Math.sqrt(3) * q + Math.sqrt(3) / 2 * r) + WORLD_WIDTH / 2;
                const y = HEX_SIZE * (3 / 2 * r) + WORLD_HEIGHT / 2;
                return { x, y };
            },

            pixelToHex: function (x, y) {
                x -= WORLD_WIDTH / 2;
                y -= WORLD_HEIGHT / 2;

                const q = (Math.sqrt(3) / 3 * x - 1 / 3 * y) / HEX_SIZE;
                const r = (2 / 3 * y) / HEX_SIZE;

                return this.roundHex(q, r);
            },

            roundHex: function (q, r) {
                const s = -q - r;
                let rq = Math.round(q);
                let rr = Math.round(r);
                let rs = Math.round(s);

                const q_diff = Math.abs(rq - q);
                const r_diff = Math.abs(rr - r);
                const s_diff = Math.abs(rs - s);

                if (q_diff > r_diff && q_diff > s_diff) {
                    rq = -rr - rs;
                } else if (r_diff > s_diff) {
                    rr = -rq - rs;
                }

                return { q: rq, r: rr };
            }
        };

        // Asset loading
        function loadAssets() {
            let assetsLoaded = 0;
            let totalAssets = 1; // Start with background

            // Count total assets (8 directions × number of animations)
            const directions = ['dir1', 'dir2', 'dir3', 'dir4', 'dir5', 'dir6', 'dir7', 'dir8'];
            const animations = ['Idle', 'Walk', 'Run', 'Attack', 'Jump', 'Die']; // Available animations
            totalAssets += directions.length * animations.length;

            // Load background
            game.assets.background = new Image();
            game.assets.background.onload = () => {
                assetsLoaded++;
                checkAssetsLoaded();
            };
            game.assets.background.onerror = () => {
                console.log("Background failed to load, using placeholder");
                assetsLoaded++;
                game.assets.background = null;
                checkAssetsLoaded();
            };
            game.assets.background.src = 'IsometricBridge.jpg';

            // Load knight sprites for each direction
            directions.forEach(dir => {
                game.assets.knightSprites[dir] = {};

                animations.forEach(anim => {
                    const sprite = new Image();
                    sprite.onload = () => {
                        assetsLoaded++;
                        checkAssetsLoaded();
                    };
                    sprite.onerror = () => {
                        console.log(`Failed to load Knight_${anim}_${dir}.png`);
                        assetsLoaded++;
                        checkAssetsLoaded();
                    };
                    // Path based on your file structure
                    sprite.src = `sprites/KnightBasic/${anim}/Knight_${anim}_${dir}.png`;
                    game.assets.knightSprites[dir][anim.toLowerCase()] = sprite;
                });
            });

            function checkAssetsLoaded() {
                const loadPercent = Math.round((assetsLoaded / totalAssets) * 100);
                loadStatusEl.textContent = `Loading: ${loadPercent}%`;

                if (assetsLoaded === totalAssets) {
                    loadStatusEl.textContent = 'Ready';
                    loadStatusEl.style.color = '#0f0';

                    // Set PC starting position
                    const startPos = HexGrid.hexToPixel(game.pc.hexQ, game.pc.hexR);
                    game.pc.pixelX = startPos.x;
                    game.pc.pixelY = startPos.y;

                    // Center camera on PC
                    centerCameraOn(game.pc.pixelX, game.pc.pixelY);

                    // Start render loop
                    gameLoop();
                }
            }
        }

        // Center camera on a world position
        function centerCameraOn(worldX, worldY) {
            cameraX = (worldX * zoomLevel) - VIEWPORT_WIDTH / 2;
            cameraY = (worldY * zoomLevel) - VIEWPORT_HEIGHT / 2;
            clampCamera();
        }

        // Keep camera within world bounds
        function clampCamera() {
            const maxCameraX = WORLD_WIDTH * zoomLevel - VIEWPORT_WIDTH;
            const maxCameraY = WORLD_HEIGHT * zoomLevel - VIEWPORT_HEIGHT;

            cameraX = Math.max(0, Math.min(cameraX, maxCameraX));
            cameraY = Math.max(0, Math.min(cameraY, maxCameraY));

            // Update debug display
            cameraPosEl.textContent = `${Math.round(cameraX)}, ${Math.round(cameraY)}`;
        }

        // Game loop
        function gameLoop() {
            updateAnimations();
            render();
            requestAnimationFrame(gameLoop);
        }

        // Update animations
        function updateAnimations() {
            // Animation speed (lower = faster)
            const ANIMATION_SPEED = 150; // milliseconds per frame

            game.pc.animationTimer += 16; // Approximately 60fps

            if (game.pc.animationTimer >= ANIMATION_SPEED) {
                game.pc.animationTimer = 0;

                // Get frame count for current animation
                let frameCount = 6; // Default for idle

                // Frame counts based on sprite sheet layouts
                switch (game.pc.currentAnimation) {
                    case 'idle':
                        frameCount = 17; // I can see 17 frames in the idle sheet (5×3 + 2)
                        break;
                    case 'walk':
                        frameCount = 8;  // Common for walk cycles
                        break;
                    case 'run':
                        frameCount = 8;  // Common for run cycles
                        break;
                    case 'attack':
                        frameCount = 10; // Attacks often have more frames
                        break;
                    case 'jump':
                        frameCount = 10; // Jump animations vary
                        break;
                    case 'die':
                        frameCount = 12; // Death animations are often longer
                        break;
                }

                // Advance to next frame
                game.pc.animationFrame = (game.pc.animationFrame + 1) % frameCount;
            }
        }

        // Rendering
        function render() {
            // Clear canvas
            ctx.fillStyle = '#2a2a2a';
            ctx.fillRect(0, 0, VIEWPORT_WIDTH, VIEWPORT_HEIGHT);

            // Save context state
            ctx.save();

            // Apply camera transform
            ctx.scale(zoomLevel, zoomLevel);
            ctx.translate(-cameraX / zoomLevel, -cameraY / zoomLevel);

            // Draw background
            if (game.assets.background) {
                ctx.drawImage(game.assets.background, 0, 0, WORLD_WIDTH, WORLD_HEIGHT);
            } else {
                // Placeholder background
                ctx.fillStyle = '#1a3a1a';
                ctx.fillRect(0, 0, WORLD_WIDTH, WORLD_HEIGHT);

                ctx.strokeStyle = '#0a2a0a';
                ctx.lineWidth = 1;
                for (let x = 0; x < WORLD_WIDTH; x += 100) {
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, WORLD_HEIGHT);
                    ctx.stroke();
                }
                for (let y = 0; y < WORLD_HEIGHT; y += 100) {
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(WORLD_WIDTH, y);
                    ctx.stroke();
                }
            }

            // Draw PC
            if (game.assets.knightSprites[game.pc.facing] &&
                game.assets.knightSprites[game.pc.facing][game.pc.currentAnimation]) {

                const sprite = game.assets.knightSprites[game.pc.facing][game.pc.currentAnimation];
                const frameSize = 256; // Each frame is 256x256

                // Sprite sheets are arranged in a grid
                const framesPerRow = 5; // 5 frames per row based on your image

                // Calculate grid position
                const col = game.pc.animationFrame % framesPerRow;
                const row = Math.floor(game.pc.animationFrame / framesPerRow);

                // Calculate pixel position in sprite sheet
                const frameX = col * frameSize;
                const frameY = row * frameSize;

                // Debug: log sprite sheet info occasionally
                if (game.pc.animationFrame === 0 && Math.random() < 0.01) {
                    console.log(`Drawing ${game.pc.currentAnimation} frame ${game.pc.animationFrame}, pos: ${col},${row}`);
                }

                ctx.drawImage(
                    sprite,
                    frameX, frameY, frameSize, frameSize, // Source
                    game.pc.pixelX - frameSize / 2, game.pc.pixelY - frameSize / 2, frameSize, frameSize // Destination
                );
            } else {
                console.log('Sprite not found:', game.pc.facing, game.pc.currentAnimation);
                console.log('Available sprites:', game.assets.knightSprites);

                // Placeholder PC
                ctx.fillStyle = '#ff0000';
                ctx.beginPath();
                ctx.arc(game.pc.pixelX, game.pc.pixelY, 30, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 3;
                ctx.stroke();
            }

            // Draw hex grid
            if (showGridCheckbox.checked) {
                drawHexGrid();
            }

            // Restore context state
            ctx.restore();
        }

        // Draw hex grid (only visible hexes)
        function drawHexGrid() {
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
            ctx.lineWidth = 2;

            // Calculate visible hex bounds with extra margin
            const margin = HEX_SIZE * 2;
            const startX = (cameraX / zoomLevel) - margin;
            const startY = (cameraY / zoomLevel) - margin;
            const endX = ((cameraX + VIEWPORT_WIDTH) / zoomLevel) + margin;
            const endY = ((cameraY + VIEWPORT_HEIGHT) / zoomLevel) + margin;

            // Convert to hex coordinates
            const startHex = HexGrid.pixelToHex(startX, startY);
            const endHex = HexGrid.pixelToHex(endX, endY);

            // Draw only visible hexes with extra buffer
            for (let q = startHex.q - 5; q <= endHex.q + 5; q++) {
                for (let r = startHex.r - 5; r <= endHex.r + 5; r++) {
                    const pos = HexGrid.hexToPixel(q, r);
                    // Only draw if hex center is within world bounds
                    if (pos.x >= -HEX_SIZE && pos.x <= WORLD_WIDTH + HEX_SIZE &&
                        pos.y >= -HEX_SIZE && pos.y <= WORLD_HEIGHT + HEX_SIZE) {
                        drawHex(q, r);
                    }
                }
            }
        }

        // Draw a single hex
        function drawHex(q, r) {
            const center = HexGrid.hexToPixel(q, r);

            ctx.beginPath();
            for (let i = 0; i < 6; i++) {
                const angle = 2 * Math.PI / 6 * i - Math.PI / 6;
                const x = center.x + HEX_SIZE * Math.cos(angle);
                const y = center.y + HEX_SIZE * Math.sin(angle);

                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.closePath();
            ctx.stroke();
        }

        // Mouse edge scrolling with variable speed
        let mouseX = 0;
        let mouseY = 0;
        let isMouseOverCanvas = false;

        canvas.addEventListener('mouseenter', () => isMouseOverCanvas = true);
        canvas.addEventListener('mouseleave', () => isMouseOverCanvas = false);

        function updateEdgeScrolling() {
            if (!isMouseOverCanvas) {
                requestAnimationFrame(updateEdgeScrolling);
                return;
            }

            const EDGE_THRESHOLD = 150;
            const MAX_SCROLL_SPEED = 12; // Reduced from 25

            const rect = canvas.getBoundingClientRect();
            const relativeX = mouseX - rect.left;
            const relativeY = mouseY - rect.top;

            let scrollX = 0;
            let scrollY = 0;

            // Calculate distance from edges
            const leftDistance = relativeX;
            const rightDistance = rect.width - relativeX;
            const topDistance = relativeY;
            const bottomDistance = rect.height - relativeY;

            // Variable speed based on distance from edge
            if (leftDistance < EDGE_THRESHOLD && leftDistance >= 0) {
                const speedMultiplier = 1 - (leftDistance / EDGE_THRESHOLD);
                scrollX = -MAX_SCROLL_SPEED * speedMultiplier;
            } else if (rightDistance < EDGE_THRESHOLD && rightDistance >= 0) {
                const speedMultiplier = 1 - (rightDistance / EDGE_THRESHOLD);
                scrollX = MAX_SCROLL_SPEED * speedMultiplier;
            }

            if (topDistance < EDGE_THRESHOLD && topDistance >= 0) {
                const speedMultiplier = 1 - (topDistance / EDGE_THRESHOLD);
                scrollY = -MAX_SCROLL_SPEED * speedMultiplier;
            } else if (bottomDistance < EDGE_THRESHOLD && bottomDistance >= 0) {
                const speedMultiplier = 1 - (bottomDistance / EDGE_THRESHOLD);
                scrollY = MAX_SCROLL_SPEED * speedMultiplier;
            }

            // Apply scrolling
            if (scrollX !== 0 || scrollY !== 0) {
                cameraX += scrollX;
                cameraY += scrollY;
                clampCamera();
            }

            requestAnimationFrame(updateEdgeScrolling);
        }
        updateEdgeScrolling();

        // Mouse handling
        canvas.addEventListener('mousemove', (e) => {
            mouseX = e.clientX;
            mouseY = e.clientY;

            const rect = canvas.getBoundingClientRect();
            const canvasX = e.clientX - rect.left;
            const canvasY = e.clientY - rect.top;

            // Convert to world coordinates
            const worldX = (canvasX + cameraX) / zoomLevel;
            const worldY = (canvasY + cameraY) / zoomLevel;

            mousePosEl.textContent = `${Math.round(worldX)}, ${Math.round(worldY)}`;

            const hex = HexGrid.pixelToHex(worldX, worldY);
            hexPosEl.textContent = `${hex.q}, ${hex.r}`;
        });

        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const canvasX = e.clientX - rect.left;
            const canvasY = e.clientY - rect.top;

            // Convert to world coordinates
            const worldX = (canvasX + cameraX) / zoomLevel;
            const worldY = (canvasY + cameraY) / zoomLevel;

            const hex = HexGrid.pixelToHex(worldX, worldY);
            console.log(`Clicked hex: q=${hex.q}, r=${hex.r}`);

            // Calculate direction to face
            const targetPos = HexGrid.hexToPixel(hex.q, hex.r);
            const dx = targetPos.x - game.pc.pixelX;
            const dy = targetPos.y - game.pc.pixelY;

            // Calculate angle and convert to 8-direction
            let angle = Math.atan2(dy, dx) * 180 / Math.PI;
            angle = (angle + 360) % 360; // Normalize to 0-360

            // Map angle to direction
            if (angle >= 337.5 || angle < 22.5) game.pc.facing = 'dir6';      // Right
            else if (angle >= 22.5 && angle < 67.5) game.pc.facing = 'dir7';  // Down-Right
            else if (angle >= 67.5 && angle < 112.5) game.pc.facing = 'dir8'; // Down
            else if (angle >= 112.5 && angle < 157.5) game.pc.facing = 'dir1'; // Down-Left
            else if (angle >= 157.5 && angle < 202.5) game.pc.facing = 'dir2'; // Left
            else if (angle >= 202.5 && angle < 247.5) game.pc.facing = 'dir3'; // Up-Left
            else if (angle >= 247.5 && angle < 292.5) game.pc.facing = 'dir4'; // Up
            else if (angle >= 292.5 && angle < 337.5) game.pc.facing = 'dir5'; // Up-Right

            // Update debug display
            directionEl.textContent = game.pc.facing;
        });

        // Keyboard controls
        document.addEventListener('keydown', (e) => {
            const KEYBOARD_SCROLL_SPEED = 15; // Reduced from 30

            switch (e.key) {
                case 'ArrowUp':
                case 'w':
                case 'W':
                    cameraY -= KEYBOARD_SCROLL_SPEED;
                    clampCamera();
                    break;
                case 'ArrowDown':
                case 's':
                case 'S':
                    cameraY += KEYBOARD_SCROLL_SPEED;
                    clampCamera();
                    break;
                case 'ArrowLeft':
                case 'a':
                case 'A':
                    cameraX -= KEYBOARD_SCROLL_SPEED;
                    clampCamera();
                    break;
                case 'ArrowRight':
                case 'd':
                case 'D':
                    cameraX += KEYBOARD_SCROLL_SPEED;
                    clampCamera();
                    break;
                // Test different animations
                case '1':
                    game.pc.currentAnimation = 'idle';
                    console.log('Animation: Idle');
                    break;
                case '2':
                    game.pc.currentAnimation = 'walk';
                    console.log('Animation: Walk');
                    break;
                case '3':
                    game.pc.currentAnimation = 'run';
                    console.log('Animation: Run');
                    break;
                case '4':
                    game.pc.currentAnimation = 'attack';
                    console.log('Animation: Attack');
                    break;
                case '5':
                    game.pc.currentAnimation = 'jump';
                    console.log('Animation: Jump');
                    break;
                case '6':
                    game.pc.currentAnimation = 'die';
                    console.log('Animation: Die');
                    break;
            }

            // Update animation display
            if (game.pc.currentAnimation) {
                animationEl.textContent = game.pc.currentAnimation;
            }
        });

        // Grid toggle listener
        showGridCheckbox.addEventListener('change', () => {
            requestAnimationFrame(render);
        });

        // Initialize
        loadAssets();
    </script>
</body>

</html>