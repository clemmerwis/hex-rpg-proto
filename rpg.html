<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hex RPG Prototype</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #1a1a1a;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            height: 100vh;
            font-family: Arial, sans-serif;
            overflow: hidden;
        }

        #gameCanvas {
            margin-top: 20px;
            border: 2px solid #333;
            cursor: pointer;
            display: block;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
        }

        #debugInfo {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: #ffffff;
            background-color: rgba(0, 0, 0, 0.8);
            padding: 15px 25px;
            border-radius: 5px;
            font-size: 14px;
            font-family: monospace;
            border: 1px solid rgba(255, 255, 255, 0.3);
            z-index: 1000;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.9);
            text-align: center;
        }

        #debugInfo label {
            color: #ffffff;
            cursor: pointer;
        }

        #debugInfo input[type="checkbox"] {
            margin-right: 5px;
            cursor: pointer;
        }
    </style>
</head>

<body>
    <canvas id="gameCanvas"></canvas>

    <div id="debugInfo">
        <div>Mouse: <span id="mousePos">0, 0</span></div>
        <div>Hex: <span id="hexPos">-, -</span></div>
        <div>Assets: <span id="loadStatus">Loading...</span></div>
        <div><label><input type="checkbox" id="showGrid" checked> Show Grid</label></div>
        <div style="margin-top: 10px; font-size: 12px;">
            <strong>Edge Scroll:</strong> Move mouse to edges<br>
            <strong>Camera:</strong> <span id="cameraPos">0, 0</span><br>
            <strong>PC Direction:</strong> <span id="directionInfo">dir8</span><br>
            <strong>Animation:</strong> <span id="animationInfo">idle</span><br>
            <strong>Keys:</strong> 1-6 for animations, 7 to spawn enemy, Click to face direction
        </div>
    </div>

    <script>
        // World size (full gameboard)
        const WORLD_WIDTH = 3220;
        const WORLD_HEIGHT = 2240;

        // Viewport size (what we see on screen)
        const VIEWPORT_WIDTH = Math.min(window.innerWidth * 0.9, 1600);
        const VIEWPORT_HEIGHT = Math.min(window.innerHeight * 0.85, 900);

        // Camera position (top-left corner of viewport in world coordinates)
        let cameraX = 0;
        let cameraY = 0;

        // Zoom level (fixed, far out view)
        const zoomLevel = 0.5; // Smaller value = farther out

        // Canvas setup
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Set canvas to viewport size
        canvas.width = VIEWPORT_WIDTH;
        canvas.height = VIEWPORT_HEIGHT;

        // Debug elements
        const mousePosEl = document.getElementById('mousePos');
        const hexPosEl = document.getElementById('hexPos');
        const loadStatusEl = document.getElementById('loadStatus');
        const showGridCheckbox = document.getElementById('showGrid');
        const cameraPosEl = document.getElementById('cameraPos');
        const directionEl = document.getElementById('directionInfo');
        const animationEl = document.getElementById('animationInfo');

        // Key state tracking for diagonal movement
        const keys = {};

        // Animation configuration
        const animationConfig = {
            'idle': { cols: 5, rows: 4, frameCount: 17 },
            'walk': { cols: 4, rows: 3, frameCount: 11 },
            'run': { cols: 3, rows: 3, frameCount: 8 },
            'jump': { cols: 4, rows: 3, frameCount: 11 },
            'attack': { cols: 4, rows: 4, frameCount: 15 },
            'die': { cols: 6, rows: 5, frameCount: 27 }
        };

        // Faction system with color tints
        const FACTIONS = {
            player: {
                name: 'Player',
                tintColor: '#4CAF50',  // Green
                nameplateColor: '#00ff00'
            },
            enemy: {
                name: 'Enemy',
                tintColor: '#F44336',  // Red
                nameplateColor: '#ff4444'
            },
            ally: {
                name: 'Ally',
                tintColor: '#2196F3',  // Blue
                nameplateColor: '#4488ff'
            },
            neutral: {
                name: 'Neutral',
                tintColor: '#FF9800',  // Orange
                nameplateColor: '#ffaa44'
            }
        };

        // Game state
        const game = {
            assets: {
                background: null,
                baseKnightSprites: {} // Only store base sprites, no tinting needed
            },
            pc: {
                hexQ: 5,
                hexR: -5,
                pixelX: 0,
                pixelY: 0,
                facing: 'dir8',
                animationFrame: 0,
                animationTimer: 0,
                currentAnimation: 'idle',
                name: 'Hero',
                health: 85,
                maxHealth: 100,
                faction: 'player'
            },
            npcs: [
                {
                    hexQ: 7,
                    hexR: -3,
                    pixelX: 0,
                    pixelY: 0,
                    facing: 'dir4',
                    animationFrame: 3,
                    animationTimer: 75,
                    currentAnimation: 'idle',
                    name: 'Guard',
                    health: 60,
                    maxHealth: 80,
                    faction: 'ally'
                },
                {
                    hexQ: 3,
                    hexR: -7,
                    pixelX: 0,
                    pixelY: 0,
                    facing: 'dir6',
                    animationFrame: 8,
                    animationTimer: 25,
                    currentAnimation: 'idle',
                    name: 'Bandit',
                    health: 45,
                    maxHealth: 60,
                    faction: 'enemy'
                }
            ]
        };

        // Hex grid configuration
        const HEX_SIZE = 70;
        const HEX_WIDTH = Math.sqrt(3) * HEX_SIZE;
        const HEX_HEIGHT = 2 * HEX_SIZE;

        // Hex grid utilities
        const HexGrid = {
            hexToPixel: function (q, r) {
                const x = HEX_SIZE * (Math.sqrt(3) * q + Math.sqrt(3) / 2 * r) + WORLD_WIDTH / 2;
                const y = HEX_SIZE * (3 / 2 * r) + WORLD_HEIGHT / 2;
                return { x, y };
            },

            pixelToHex: function (x, y) {
                x -= WORLD_WIDTH / 2;
                y -= WORLD_HEIGHT / 2;

                const q = (Math.sqrt(3) / 3 * x - 1 / 3 * y) / HEX_SIZE;
                const r = (2 / 3 * y) / HEX_SIZE;

                return this.roundHex(q, r);
            },

            roundHex: function (q, r) {
                const s = -q - r;
                let rq = Math.round(q);
                let rr = Math.round(r);
                let rs = Math.round(s);

                const q_diff = Math.abs(rq - q);
                const r_diff = Math.abs(rr - r);
                const s_diff = Math.abs(rs - s);

                if (q_diff > r_diff && q_diff > s_diff) {
                    rq = -rr - rs;
                } else if (r_diff > s_diff) {
                    rr = -rq - rs;
                }

                return { q: rq, r: rr };
            }
        };

        // Color tinting functions - REMOVED (caused CORS issues)
        // Using hex border coloring instead of sprite tinting

        // Draw hex grid with character-based coloring
        function drawHexGrid() {
            console.log('drawHexGrid() called!');

            const margin = HEX_SIZE * 2;
            const startX = (cameraX / zoomLevel) - margin;
            const startY = (cameraY / zoomLevel) - margin;
            const endX = ((cameraX + VIEWPORT_WIDTH) / zoomLevel) + margin;
            const endY = ((cameraY + VIEWPORT_HEIGHT) / zoomLevel) + margin;

            const startHex = HexGrid.pixelToHex(startX, startY);
            const endHex = HexGrid.pixelToHex(endX, endY);

            console.log(`Drawing hexes from ${startHex.q},${startHex.r} to ${endHex.q},${endHex.r}`);

            for (let q = startHex.q - 5; q <= endHex.q + 5; q++) {
                for (let r = startHex.r - 5; r <= endHex.r + 5; r++) {
                    const pos = HexGrid.hexToPixel(q, r);
                    if (pos.x >= -HEX_SIZE && pos.x <= WORLD_WIDTH + HEX_SIZE &&
                        pos.y >= -HEX_SIZE && pos.y <= WORLD_HEIGHT + HEX_SIZE) {

                        // Debug for Hero's hex specifically
                        if (q === 5 && r === -5) {
                            console.log(`About to draw Hero's hex at ${q},${r}`);
                        }

                        drawHexWithCharacterColors(q, r);
                    }
                }
            }
        }

        // Draw a single hex with character-based coloring and border gradients
        function drawHexWithCharacterColors(q, r) {
            const center = HexGrid.hexToPixel(q, r);
            const characterHere = getCharacterAtHex(q, r);

            // Debug: Check if we're drawing the Hero's hex
            if (q === 5 && r === -5) {
                console.log(`Drawing Hero's hex at ${q},${r} - Character found:`, characterHere ? characterHere.name : 'NONE');
            }

            // Define the 6 adjacent hex directions (clockwise from right)
            const adjacentDirs = [
                [1, 0],   // Right
                [0, 1],   // Down-Right  
                [-1, 1],  // Down-Left
                [-1, 0],  // Left
                [0, -1],  // Up-Left
                [1, -1]   // Up-Right
            ];

            // Calculate hex corner points
            const hexPoints = [];
            for (let i = 0; i < 6; i++) {
                const angle = 2 * Math.PI / 6 * i - Math.PI / 6;
                const x = center.x + HEX_SIZE * Math.cos(angle);
                const y = center.y + HEX_SIZE * Math.sin(angle);
                hexPoints.push({ x, y });
            }

            // ALWAYS draw the default grid first
            ctx.beginPath();
            hexPoints.forEach((point, i) => {
                if (i === 0) {
                    ctx.moveTo(point.x, point.y);
                } else {
                    ctx.lineTo(point.x, point.y);
                }
            });
            ctx.closePath();
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
            ctx.lineWidth = 2;
            ctx.stroke();

            // If character is on this hex, draw thick colored border ON TOP
            if (characterHere) {
                const factionData = FACTIONS[characterHere.faction] || FACTIONS.neutral;

                if (q === 5 && r === -5) {
                    console.log(`Drawing THICK border for ${characterHere.name} with color ${factionData.tintColor}`);
                }

                // Draw a very obvious test border first
                ctx.beginPath();
                hexPoints.forEach((point, i) => {
                    if (i === 0) {
                        ctx.moveTo(point.x, point.y);
                    } else {
                        ctx.lineTo(point.x, point.y);
                    }
                });
                ctx.closePath();

                // Make it EXTREMELY visible for testing
                ctx.strokeStyle = '#FF00FF'; // Bright magenta - impossible to miss
                ctx.lineWidth = 20; // VERY thick
                ctx.stroke();

                if (q === 5 && r === -5) {
                    console.log(`Should have drawn MAGENTA border around Hero's hex!`);
                }
            }
        }

        // Get character at specific hex coordinate (should be max 1)
        function getCharacterAtHex(q, r) {
            // Check PC first
            if (game.pc.hexQ === q && game.pc.hexR === r) {
                return game.pc;
            }

            // Check NPCs
            for (let npc of game.npcs) {
                if (npc.hexQ === q && npc.hexR === r) {
                    return npc;
                }
            }

            return null;
        }

        // Asset loading
        function loadAssets() {
            let assetsLoaded = 0;
            let totalAssets = 1; // Start with background

            // Count total assets (8 directions × number of animations)
            const directions = ['dir1', 'dir2', 'dir3', 'dir4', 'dir5', 'dir6', 'dir7', 'dir8'];
            const animations = ['Idle', 'Walk', 'Run', 'Attack', 'Jump', 'Die'];
            totalAssets += directions.length * animations.length;

            // Load background
            game.assets.background = new Image();
            game.assets.background.onload = () => {
                assetsLoaded++;
                checkAssetsLoaded();
            };
            game.assets.background.onerror = () => {
                console.log("Background failed to load, using placeholder");
                assetsLoaded++;
                game.assets.background = null;
                checkAssetsLoaded();
            };
            game.assets.background.src = 'IsometricBridge.jpg';

            // Load knight sprites for each direction
            directions.forEach(dir => {
                game.assets.baseKnightSprites[dir] = {};

                animations.forEach(anim => {
                    const sprite = new Image();
                    sprite.onload = () => {
                        assetsLoaded++;
                        checkAssetsLoaded();
                    };
                    sprite.onerror = () => {
                        console.log(`Failed to load Knight_${anim}_${dir}.png`);
                        assetsLoaded++;
                        checkAssetsLoaded();
                    };
                    sprite.src = `sprites/KnightBasic/${anim}/Knight_${anim}_${dir}.png`;
                    game.assets.baseKnightSprites[dir][anim.toLowerCase()] = sprite;
                });
            });

            function checkAssetsLoaded() {
                const loadPercent = Math.round((assetsLoaded / totalAssets) * 100);
                loadStatusEl.textContent = `Loading: ${loadPercent}%`;

                if (assetsLoaded === totalAssets) {
                    loadStatusEl.textContent = 'Ready - Press 7 to spawn, 8 to debug positions';
                    loadStatusEl.style.color = '#0f0';

                    // Set PC starting position
                    const startPos = HexGrid.hexToPixel(game.pc.hexQ, game.pc.hexR);
                    game.pc.pixelX = startPos.x;
                    game.pc.pixelY = startPos.y;

                    // Set NPC starting positions
                    game.npcs.forEach(npc => {
                        const npcStartPos = HexGrid.hexToPixel(npc.hexQ, npc.hexR);
                        npc.pixelX = npcStartPos.x;
                        npc.pixelY = npcStartPos.y;
                    });

                    centerCameraOn(game.pc.pixelX, game.pc.pixelY);
                    gameLoop();
                }
            }
        }

        // Center camera on a world position
        function centerCameraOn(worldX, worldY) {
            cameraX = (worldX * zoomLevel) - VIEWPORT_WIDTH / 2;
            cameraY = (worldY * zoomLevel) - VIEWPORT_HEIGHT / 2;
            clampCamera();
        }

        // Keep camera within world bounds
        function clampCamera() {
            const maxCameraX = WORLD_WIDTH * zoomLevel - VIEWPORT_WIDTH;
            const maxCameraY = WORLD_HEIGHT * zoomLevel - VIEWPORT_HEIGHT;

            cameraX = Math.max(0, Math.min(cameraX, maxCameraX));
            cameraY = Math.max(0, Math.min(cameraY, maxCameraY));

            cameraPosEl.textContent = `${Math.round(cameraX)}, ${Math.round(cameraY)}`;
        }

        // Game loop
        function gameLoop() {
            updateAnimations();
            updateKeyboardScrolling();
            render();
            requestAnimationFrame(gameLoop);
        }

        // Update animations
        function updateAnimations() {
            const ANIMATION_SPEED = 150;

            // Update PC animation
            game.pc.animationTimer += 16;
            if (game.pc.animationTimer >= ANIMATION_SPEED) {
                game.pc.animationTimer = 0;
                const animConfig = animationConfig[game.pc.currentAnimation];
                let frameCount = animConfig ? animConfig.frameCount : 6;
                game.pc.animationFrame = (game.pc.animationFrame + 1) % frameCount;
            }

            // Update NPC animations
            game.npcs.forEach(npc => {
                npc.animationTimer += 16;
                if (npc.animationTimer >= ANIMATION_SPEED) {
                    npc.animationTimer = 0;
                    const animConfig = animationConfig[npc.currentAnimation];
                    let frameCount = animConfig ? animConfig.frameCount : 6;
                    npc.animationFrame = (npc.animationFrame + 1) % frameCount;
                }
            });
        }

        // Update keyboard scrolling
        function updateKeyboardScrolling() {
            const KEYBOARD_SCROLL_SPEED = 15;

            let scrollX = 0;
            let scrollY = 0;

            if (keys['ArrowUp'] || keys['w'] || keys['W']) scrollY -= KEYBOARD_SCROLL_SPEED;
            if (keys['ArrowDown'] || keys['s'] || keys['S']) scrollY += KEYBOARD_SCROLL_SPEED;
            if (keys['ArrowLeft'] || keys['a'] || keys['A']) scrollX -= KEYBOARD_SCROLL_SPEED;
            if (keys['ArrowRight'] || keys['d'] || keys['D']) scrollX += KEYBOARD_SCROLL_SPEED;

            if (scrollX !== 0 || scrollY !== 0) {
                keyboardScrollActive = true; // Flag that keyboard scrolling is happening
                cameraX += scrollX;
                cameraY += scrollY;
                clampCamera();
            }
        }

        // Draw nameplate with faction colors
        function drawNameplate(character, isPC = false) {
            const actualSpriteSize = 256 * zoomLevel;
            const nameplateY = character.pixelY - actualSpriteSize / 2 - 45;

            const barWidth = 150;  // Slightly wider
            const barHeight = 22;  // Slightly taller
            const nameplatePadding = 8;
            const nameplateWidth = Math.max(barWidth, 120) + (nameplatePadding * 2);
            const nameplateHeight = 65;  // Reduced height
            const nameplateX = character.pixelX - nameplateWidth / 2;
            const nameplateBackgroundY = nameplateY - 40;  // Adjusted for smaller text

            ctx.save();

            // Draw semi-transparent black background
            ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
            ctx.fillRect(nameplateX, nameplateBackgroundY, nameplateWidth, nameplateHeight);

            // Consistent border for all characters
            const factionData = FACTIONS[character.faction] || FACTIONS.neutral;
            ctx.strokeStyle = factionData.nameplateColor;
            ctx.lineWidth = 2;  // Same thickness for everyone
            ctx.strokeRect(nameplateX, nameplateBackgroundY, nameplateWidth, nameplateHeight);

            // Name text - smaller font
            ctx.font = 'bold 28px Arial';  // Reduced from 36px to 28px
            ctx.textAlign = 'center';
            ctx.textBaseline = 'bottom';

            // Text shadow
            ctx.fillStyle = 'rgba(0, 0, 0, 0.9)';
            ctx.fillText(character.name, character.pixelX + 2, nameplateY + 2);

            // Main text color
            ctx.fillStyle = factionData.nameplateColor;
            ctx.fillText(character.name, character.pixelX, nameplateY);

            // Health bar
            const barX = character.pixelX - barWidth / 2;
            const barY = nameplateY + 8;  // Adjusted spacing

            // Background (dark red)
            ctx.fillStyle = 'rgba(150, 0, 0, 0.9)';
            ctx.fillRect(barX, barY, barWidth, barHeight);

            // Health fill (green)
            const healthPercent = character.health / character.maxHealth;
            const healthWidth = barWidth * healthPercent;
            ctx.fillStyle = 'rgba(0, 200, 0, 0.9)';
            ctx.fillRect(barX, barY, healthWidth, barHeight);

            // Health bar border
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.9)';
            ctx.lineWidth = 3;
            ctx.strokeRect(barX, barY, barWidth, barHeight);

            // Health text
            ctx.font = 'bold 18px Arial';  // Slightly smaller
            ctx.fillStyle = 'white';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(`${character.health}/${character.maxHealth}`, character.pixelX, barY + barHeight / 2);

            ctx.restore();
        }

        // Draw character sprite (no tinting, use original sprites)
        function drawCharacter(character) {
            // Use base sprites directly - no tinting needed since we use hex borders for faction identification
            const sprite = game.assets.baseKnightSprites[character.facing] &&
                game.assets.baseKnightSprites[character.facing][character.currentAnimation];

            if (sprite && sprite.complete) {
                const frameSize = 256;
                const animConfig = animationConfig[character.currentAnimation];
                const framesPerRow = animConfig ? animConfig.cols : Math.floor(sprite.width / frameSize);

                const col = character.animationFrame % framesPerRow;
                const row = Math.floor(character.animationFrame / framesPerRow);

                const frameX = col * frameSize;
                const frameY = row * frameSize;

                // Draw the sprite frame
                if (frameX + frameSize <= sprite.width && frameY + frameSize <= sprite.height) {
                    ctx.drawImage(
                        sprite,
                        frameX, frameY, frameSize, frameSize,
                        character.pixelX - frameSize / 2, character.pixelY - frameSize / 2, frameSize, frameSize
                    );
                } else {
                    // Fallback to first frame if calculated frame is out of bounds
                    ctx.drawImage(
                        sprite,
                        0, 0, frameSize, frameSize,
                        character.pixelX - frameSize / 2, character.pixelY - frameSize / 2, frameSize, frameSize
                    );
                }
            } else {
                // Placeholder character with faction color
                const factionData = FACTIONS[character.faction] || FACTIONS.neutral;
                ctx.fillStyle = factionData.tintColor;
                ctx.beginPath();
                ctx.arc(character.pixelX, character.pixelY, 30, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 3;
                ctx.stroke();
            }
        }

        // Rendering
        function render() {
            ctx.fillStyle = '#2a2a2a';
            ctx.fillRect(0, 0, VIEWPORT_WIDTH, VIEWPORT_HEIGHT);

            ctx.save();
            ctx.scale(zoomLevel, zoomLevel);
            ctx.translate(-cameraX / zoomLevel, -cameraY / zoomLevel);

            // Draw background
            if (game.assets.background) {
                ctx.drawImage(game.assets.background, 0, 0, WORLD_WIDTH, WORLD_HEIGHT);
            } else {
                ctx.fillStyle = '#1a3a1a';
                ctx.fillRect(0, 0, WORLD_WIDTH, WORLD_HEIGHT);

                ctx.strokeStyle = '#0a2a0a';
                ctx.lineWidth = 1;
                for (let x = 0; x < WORLD_WIDTH; x += 100) {
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, WORLD_HEIGHT);
                    ctx.stroke();
                }
                for (let y = 0; y < WORLD_WIDTH; y += 100) {
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(WORLD_WIDTH, y);
                    ctx.stroke();
                }
            }

            // Draw hex grid - INLINE to avoid scope issues
            console.log('About to call INLINE drawHexGrid');

            const margin = HEX_SIZE * 2;
            const startX = (cameraX / zoomLevel) - margin;
            const startY = (cameraY / zoomLevel) - margin;
            const endX = ((cameraX + VIEWPORT_WIDTH) / zoomLevel) + margin;
            const endY = ((cameraY + VIEWPORT_HEIGHT) / zoomLevel) + margin;

            const startHex = HexGrid.pixelToHex(startX, startY);
            const endHex = HexGrid.pixelToHex(endX, endY);

            console.log(`Drawing hexes from ${startHex.q},${startHex.r} to ${endHex.q},${endHex.r}`);

            for (let q = startHex.q - 5; q <= endHex.q + 5; q++) {
                for (let r = startHex.r - 5; r <= endHex.r + 5; r++) {
                    const pos = HexGrid.hexToPixel(q, r);
                    if (pos.x >= -HEX_SIZE && pos.x <= WORLD_WIDTH + HEX_SIZE &&
                        pos.y >= -HEX_SIZE && pos.y <= WORLD_HEIGHT + HEX_SIZE) {

                        // INLINE hex drawing to avoid scope issues
                        const center = HexGrid.hexToPixel(q, r);
                        const characterHere = getCharacterAtHex(q, r);

                        // Debug for Hero's hex
                        if (q === 5 && r === -5) {
                            console.log(`Drawing Hero's hex at ${q},${r} - Character:`, characterHere ? characterHere.name : 'NONE');
                        }

                        // Calculate hex corner points
                        const hexPoints = [];
                        for (let i = 0; i < 6; i++) {
                            const angle = 2 * Math.PI / 6 * i - Math.PI / 6;
                            const x = center.x + HEX_SIZE * Math.cos(angle);
                            const y = center.y + HEX_SIZE * Math.sin(angle);
                            hexPoints.push({ x, y });
                        }

                        // Draw default grid
                        ctx.beginPath();
                        hexPoints.forEach((point, i) => {
                            if (i === 0) {
                                ctx.moveTo(point.x, point.y);
                            } else {
                                ctx.lineTo(point.x, point.y);
                            }
                        });
                        ctx.closePath();
                        ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
                        ctx.lineWidth = 2;
                        ctx.stroke();

                        // If character here, draw faction-colored border
                        if (characterHere) {
                            const factionData = FACTIONS[characterHere.faction] || FACTIONS.neutral;

                            if (q === 5 && r === -5) {
                                console.log(`Drawing ${factionData.tintColor} border for ${characterHere.name} at ${q},${r}`);
                            }

                            ctx.beginPath();
                            hexPoints.forEach((point, i) => {
                                if (i === 0) {
                                    ctx.moveTo(point.x, point.y);
                                } else {
                                    ctx.lineTo(point.x, point.y);
                                }
                            });
                            ctx.closePath();

                            // Use faction color and thinner borders
                            ctx.strokeStyle = factionData.tintColor;
                            ctx.lineWidth = 4; // Reduced from 6px - thinner borders
                            ctx.stroke();

                            // Check for adjacent different factions for gradient borders
                            const adjacentDirs = [
                                [1, 0], [0, 1], [-1, 1], [-1, 0], [0, -1], [1, -1]
                            ];

                            adjacentDirs.forEach((dir, edgeIndex) => {
                                const [dq, dr] = dir;
                                const adjQ = q + dq;
                                const adjR = r + dr;
                                const adjCharacter = getCharacterAtHex(adjQ, adjR);

                                if (adjCharacter && adjCharacter.faction !== characterHere.faction) {
                                    // Different faction adjacent - create gradient on shared edge
                                    const startPoint = hexPoints[edgeIndex];
                                    const endPoint = hexPoints[(edgeIndex + 1) % 6];

                                    const adjFactionData = FACTIONS[adjCharacter.faction] || FACTIONS.neutral;

                                    const gradient = ctx.createLinearGradient(
                                        startPoint.x, startPoint.y,
                                        endPoint.x, endPoint.y
                                    );

                                    gradient.addColorStop(0, factionData.tintColor);
                                    gradient.addColorStop(1, adjFactionData.tintColor);

                                    ctx.beginPath();
                                    ctx.moveTo(startPoint.x, startPoint.y);
                                    ctx.lineTo(endPoint.x, endPoint.y);
                                    ctx.strokeStyle = gradient;
                                    ctx.lineWidth = 6; // Reduced from 8px - thinner gradient borders
                                    ctx.stroke();
                                }
                            });
                        }
                    }
                }
            }

            // Draw PC
            drawCharacter(game.pc);
            drawNameplate(game.pc, true);

            // Draw NPCs
            game.npcs.forEach(npc => {
                drawCharacter(npc);
                drawNameplate(npc, false);
            });

            ctx.restore();
        }

        // Draw hex grid
        function drawHexGrid() {
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
            ctx.lineWidth = 2;

            const margin = HEX_SIZE * 2;
            const startX = (cameraX / zoomLevel) - margin;
            const startY = (cameraY / zoomLevel) - margin;
            const endX = ((cameraX + VIEWPORT_WIDTH) / zoomLevel) + margin;
            const endY = ((cameraY + VIEWPORT_HEIGHT) / zoomLevel) + margin;

            const startHex = HexGrid.pixelToHex(startX, startY);
            const endHex = HexGrid.pixelToHex(endX, endY);

            for (let q = startHex.q - 5; q <= endHex.q + 5; q++) {
                for (let r = startHex.r - 5; r <= endHex.r + 5; r++) {
                    const pos = HexGrid.hexToPixel(q, r);
                    if (pos.x >= -HEX_SIZE && pos.x <= WORLD_WIDTH + HEX_SIZE &&
                        pos.y >= -HEX_SIZE && pos.y <= WORLD_HEIGHT + HEX_SIZE) {
                        drawHex(q, r);
                    }
                }
            }
        }

        // Draw a single hex
        function drawHex(q, r) {
            const center = HexGrid.hexToPixel(q, r);

            ctx.beginPath();
            for (let i = 0; i < 6; i++) {
                const angle = 2 * Math.PI / 6 * i - Math.PI / 6;
                const x = center.x + HEX_SIZE * Math.cos(angle);
                const y = center.y + HEX_SIZE * Math.sin(angle);

                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.closePath();
            ctx.stroke();
        }

        // Spawn enemy function
        function spawnEnemy() {
            const factions = ['enemy', 'ally', 'neutral'];
            const randomFaction = factions[Math.floor(Math.random() * factions.length)];

            const newEnemy = {
                hexQ: game.pc.hexQ + Math.floor(Math.random() * 6) - 3,
                hexR: game.pc.hexR + Math.floor(Math.random() * 6) - 3,
                pixelX: 0,
                pixelY: 0,
                facing: ['dir1', 'dir2', 'dir3', 'dir4', 'dir5', 'dir6', 'dir7', 'dir8'][Math.floor(Math.random() * 8)],
                animationFrame: Math.floor(Math.random() * 17),
                animationTimer: Math.floor(Math.random() * 150),
                currentAnimation: 'idle',
                name: randomFaction.charAt(0).toUpperCase() + randomFaction.slice(1),
                health: 50 + Math.floor(Math.random() * 30),
                maxHealth: 80,
                faction: randomFaction
            };

            const enemyPos = HexGrid.hexToPixel(newEnemy.hexQ, newEnemy.hexR);
            newEnemy.pixelX = enemyPos.x;
            newEnemy.pixelY = enemyPos.y;

            game.npcs.push(newEnemy);
            console.log(`Spawned ${randomFaction} at ${newEnemy.hexQ}, ${newEnemy.hexR}`);
        }

        // Mouse edge scrolling state
        let mouseX = 0;
        let mouseY = 0;
        let isMouseOverCanvas = false;
        let keyboardScrollActive = false;
        let mouseInEdgeZone = false;
        let wasInEdgeZone = false;

        canvas.addEventListener('mouseenter', () => isMouseOverCanvas = true);
        canvas.addEventListener('mouseleave', () => isMouseOverCanvas = false);

        function updateEdgeScrolling() {
            if (!isMouseOverCanvas) {
                requestAnimationFrame(updateEdgeScrolling);
                return;
            }

            const EDGE_THRESHOLD = 100;
            const MAX_SCROLL_SPEED = 12;

            const rect = canvas.getBoundingClientRect();
            const relativeX = mouseX - rect.left;
            const relativeY = mouseY - rect.top;

            // Check if mouse is currently in edge zone
            const leftDistance = relativeX;
            const rightDistance = rect.width - relativeX;
            const topDistance = relativeY;
            const bottomDistance = rect.height - relativeY;

            const currentlyInEdgeZone = (
                (leftDistance < EDGE_THRESHOLD && leftDistance >= 0) ||
                (rightDistance < EDGE_THRESHOLD && rightDistance >= 0) ||
                (topDistance < EDGE_THRESHOLD && topDistance >= 0) ||
                (bottomDistance < EDGE_THRESHOLD && bottomDistance >= 0)
            );

            // Track edge zone entry/exit for keyboard scroll reset
            if (!wasInEdgeZone && currentlyInEdgeZone) {
                // Mouse just entered edge zone
                mouseInEdgeZone = true;
                if (keyboardScrollActive) {
                    // Reset keyboard scroll flag when mouse re-enters edge after being outside
                    keyboardScrollActive = false;
                }
            } else if (wasInEdgeZone && !currentlyInEdgeZone) {
                // Mouse just left edge zone
                mouseInEdgeZone = false;
            }

            wasInEdgeZone = currentlyInEdgeZone;

            // Skip edge scrolling if keyboard scrolling is active
            if (keyboardScrollActive) {
                requestAnimationFrame(updateEdgeScrolling);
                return;
            }

            let scrollX = 0;
            let scrollY = 0;

            if (leftDistance < EDGE_THRESHOLD && leftDistance >= 0) {
                const speedMultiplier = 1 - (leftDistance / EDGE_THRESHOLD);
                scrollX = -MAX_SCROLL_SPEED * speedMultiplier;
            } else if (rightDistance < EDGE_THRESHOLD && rightDistance >= 0) {
                const speedMultiplier = 1 - (rightDistance / EDGE_THRESHOLD);
                scrollX = MAX_SCROLL_SPEED * speedMultiplier;
            }

            if (topDistance < EDGE_THRESHOLD && topDistance >= 0) {
                const speedMultiplier = 1 - (topDistance / EDGE_THRESHOLD);
                scrollY = -MAX_SCROLL_SPEED * speedMultiplier;
            } else if (bottomDistance < EDGE_THRESHOLD && bottomDistance >= 0) {
                const speedMultiplier = 1 - (bottomDistance / EDGE_THRESHOLD);
                scrollY = MAX_SCROLL_SPEED * speedMultiplier;
            }

            if (scrollX !== 0 || scrollY !== 0) {
                cameraX += scrollX;
                cameraY += scrollY;
                clampCamera();
            }

            requestAnimationFrame(updateEdgeScrolling);
        }
        updateEdgeScrolling();

        // Mouse handling
        canvas.addEventListener('mousemove', (e) => {
            mouseX = e.clientX;
            mouseY = e.clientY;

            const rect = canvas.getBoundingClientRect();
            const canvasX = e.clientX - rect.left;
            const canvasY = e.clientY - rect.top;

            const worldX = (canvasX + cameraX) / zoomLevel;
            const worldY = (canvasY + cameraY) / zoomLevel;

            mousePosEl.textContent = `${Math.round(worldX)}, ${Math.round(worldY)}`;

            const hex = HexGrid.pixelToHex(worldX, worldY);
            hexPosEl.textContent = `${hex.q}, ${hex.r}`;
        });

        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const canvasX = e.clientX - rect.left;
            const canvasY = e.clientY - rect.top;

            const worldX = (canvasX + cameraX) / zoomLevel;
            const worldY = (canvasY + cameraY) / zoomLevel;

            const hex = HexGrid.pixelToHex(worldX, worldY);
            console.log(`Clicked hex: q=${hex.q}, r=${hex.r}`);

            const targetPos = HexGrid.hexToPixel(hex.q, hex.r);
            const dx = targetPos.x - game.pc.pixelX;
            const dy = targetPos.y - game.pc.pixelY;

            let angle = Math.atan2(dy, dx) * 180 / Math.PI;
            angle = (angle + 360) % 360;

            if (angle >= 337.5 || angle < 22.5) game.pc.facing = 'dir6';
            else if (angle >= 22.5 && angle < 67.5) game.pc.facing = 'dir7';
            else if (angle >= 67.5 && angle < 112.5) game.pc.facing = 'dir8';
            else if (angle >= 112.5 && angle < 157.5) game.pc.facing = 'dir1';
            else if (angle >= 157.5 && angle < 202.5) game.pc.facing = 'dir2';
            else if (angle >= 202.5 && angle < 247.5) game.pc.facing = 'dir3';
            else if (angle >= 247.5 && angle < 292.5) game.pc.facing = 'dir4';
            else if (angle >= 292.5 && angle < 337.5) game.pc.facing = 'dir5';

            directionEl.textContent = game.pc.facing;
        });

        // Keyboard handling
        document.addEventListener('keydown', (e) => {
            keys[e.key] = true;

            switch (e.key) {
                case '1':
                    game.pc.currentAnimation = 'idle';
                    animationEl.textContent = game.pc.currentAnimation;
                    break;
                case '2':
                    game.pc.currentAnimation = 'walk';
                    animationEl.textContent = game.pc.currentAnimation;
                    break;
                case '3':
                    game.pc.currentAnimation = 'run';
                    animationEl.textContent = game.pc.currentAnimation;
                    break;
                case '4':
                    game.pc.currentAnimation = 'attack';
                    animationEl.textContent = game.pc.currentAnimation;
                    break;
                case '5':
                    game.pc.currentAnimation = 'jump';
                    animationEl.textContent = game.pc.currentAnimation;
                    break;
                case '6':
                    game.pc.currentAnimation = 'die';
                    animationEl.textContent = game.pc.currentAnimation;
                    break;
                case '7':
                    spawnEnemy();
                    break;
                case '8':
                    window.testCharacterPositions(); // Debug key
                    break;
            }
        });

        document.addEventListener('keyup', (e) => {
            keys[e.key] = false;
        });

        showGridCheckbox.addEventListener('change', () => {
            requestAnimationFrame(render);
        });

        // Initialize
        loadAssets();

        // Run debug after everything is loaded (wait 2 seconds)
        setTimeout(() => {
            console.log('=== CHARACTER POSITION DEBUG ===');
            console.log(`PC: hex(${game.pc.hexQ},${game.pc.hexR}) faction: ${game.pc.faction}`);

            // Test if we can find the PC at its own position
            const foundPC = getCharacterAtHex(game.pc.hexQ, game.pc.hexR);
            console.log(`Can find PC at its hex? ${foundPC ? foundPC.name : 'NO'}`);

            // Test NPCs
            game.npcs.forEach(npc => {
                console.log(`NPC ${npc.name}: hex(${npc.hexQ},${npc.hexR}) faction: ${npc.faction}`);
                const foundNPC = getCharacterAtHex(npc.hexQ, npc.hexR);
                console.log(`Can find ${npc.name} at its hex? ${foundNPC ? foundNPC.name : 'NO'}`);
            });

            // Test the faction colors
            Object.keys(FACTIONS).forEach(faction => {
                console.log(`Faction ${faction}: ${FACTIONS[faction].tintColor}`);
            });

            // Test if hex border drawing is being called
            console.log('Testing hex border drawing...');
            const testChar = getCharacterAtHex(5, -5);
            console.log(`Character at 5,-5: ${testChar ? testChar.name : 'NONE'}`);
        }, 2000);
    </script>
</body>

</html>